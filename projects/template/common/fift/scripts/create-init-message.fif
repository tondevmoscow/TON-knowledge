#!fift -s
"TonUtil.fif" include
"Asm.fif" include
"Color.fif" include

{ ."usage: " $0 type ." <compiled-code-fif-path> <init-data-fif-path> <workchain> <output-boc-path> <output-addr-path> <output-human-readable-address-path>" cr
."Generates init message and calculates contract address" cr 1 halt } : usage
$# 6 <> ' usage if
6 :$1..n
$1 constant code_path
$2 include constant data
$3 parse-workchain-id constant wc
$4 constant output_boc
$5 constant output_addr
$6 constant output_human_readable_address


// It's trick from https://t.me/tonsc_chat/949
<{ SETCP0 ACCEPT
   code_path include PUSHREF SETCODE
}>c constant code

<b b{0011} s, code ref, data ref, null dict, b> constant StateInit

StateInit hashu wc swap 2dup 2constant contract_addr
2dup output_addr save-address

// Create raw address string
2dup (dump) swap (dump) ":" $+ swap $+ constant raw_address

// Create bounceable_address
2dup 6 smca>$ constant bounceable_address

// Create Non-bounceable address
2dup 7 smca>$ constant nonbounceable_address

^magenta ."INFO: 🦄 Raw address: " raw_address type cr
^green ."INFO: 🦝 Bounceable address: " bounceable_address type cr
^yellow  ."INFO: 🐏 Non-bounceable address: " nonbounceable_address type cr
^reset

// Save all addresses to text
raw_address " " $+
bounceable_address " " $+ $+
nonbounceable_address " " $+ $+
$>B
output_human_readable_address B>file
^green "🖊  Save all addresses to " output_human_readable_address $+ type cr
^reset

<b b{1000100} s, contract_addr addr, b{000011} s, StateInit ref, b{0} s, b>
2 boc+>B
output_boc tuck B>file

^green "🖊  Save boc_file to " output_boc $+ type cr
^reset
