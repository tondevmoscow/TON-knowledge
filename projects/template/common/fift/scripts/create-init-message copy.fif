#!/usr/bin/fift -s
"TonUtil.fif" include
"Asm.fif" include
"Color.fif" include

{ ."usage: " $0 type ." compiled-code-fif-path init-data-fif-path workchain output-boc-path output-address-path" cr
."Generate init message and calculate contract address" cr 1 halt } : usage
$# 5 <> ' usage if
5 :$1..n
$1 constant code-path
$2 include constant data
$3 parse-workchain-id constant wc  // try constant instead of =: ?
$4 constant output_boc
$5 constant output_address

// It's trick from https://t.me/tonsc_chat/949
<{ SETCP0 ACCEPT
   code-path include PUSHREF SETCODE
}>c constant code

// data-path file>B B>boc constant data

<b b{0011} s, code ref, data ref, null dict, b> constant StateInit

StateInit hashu wc swap 2dup 2constant contract_addr
2dup "build/advanced_counter.addr" save-address

// Create raw address string
2dup (dump) swap (dump) ":" $+ swap $+ constant raw_address

// Create bounceable_address
2dup 6 smca>$ constant bounceable_address

// Create Non-bounceable address
2dup 7 smca>$ constant nonbounceable_address

^magenta ."INFO: ğŸ¦„ Raw address: " raw_address type cr
^green ."INFO: ğŸ¦ Bounceable address: " bounceable_address type cr
^yellow  ."INFO: ğŸ Non-bounceable address: " nonbounceable_address type cr
^reset

// Save all addresses to text
raw_address " " $+
bounceable_address " " $+ $+
nonbounceable_address " " $+ $+
$>B
output_address B>file
^green "ğŸ–Š  Save all addresses to " output_address $+ type cr
^reset

<b b{1000100} s, contract_addr addr, b{000011} s, StateInit ref, b{0} s, b>
2 boc+>B
output_boc tuck B>file

^green "ğŸ–Š  Save boc_file to " output_boc $+ type cr
^reset

